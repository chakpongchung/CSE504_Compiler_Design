%option noyywrap
%option never-interactive

%{
#include "E--_lexer.tab.h"
#include <iostream>

using namespace std;

const char* yyfilename = "";
int yylinenum = 0;

%}


/* Definitions */

DIGIT	 						 [0-9]
EXP							 [[Ee][-+]?{DIGIT}+]
HEX							"0x"[a-fA-F0-9]+
UINTNUM		  					{DIGIT}+

TOK_HASH						 [#]
ID							[a-zA-Z_][a-zA-Z0-9_]*
STRING 							[\"][a-zA-Z]*[\"]
%%




" " {}


{TOK_HASH}.*					{
							 char *temp = strtok(yytext, " ");
							  int count = 0, count1=0;
        							while (count<3) {
									
									count++;
									switch(count){
									case 2: yylinenum = atoi(temp)-1; break;
									case 3: 
										{	
										char *temp_filename = new char[40];
										count1=0;
        									while(*temp!=0)
        									{
          
         									   if(*temp!='\"')
                									{
                     
                    									temp_filename[count1++] = *temp;
                   								
                									}	
                									*temp++;
       										}	
        									temp_filename[count1] ='\0';
									        
        									yyfilename = temp_filename; break;
										}
									default: break;
									}
								
								        temp = strtok(0, " ");
      							    	}
						
							//printf("\n%s\n", yytext);
							
						}

 /**************** Recognize operators ****************/

"->"			{ return TOK_ARROW; }	
"?"			{ return TOK_QMARK; }
"\\/"			{ return TOK_PAT_OR;}
"&"			{ return TOK_BITAND;}
"|"			{ return TOK_BITOR;}
"~"			{ return TOK_BITNOT;}
":"			{ return TOK_COLON;}
","			{ return TOK_COMMA;}
"\."			{ return TOK_DOT;}
";"			{ return TOK_SEMICOLON;}
"["			{ return TOK_LBRACK;}
"]"			{ return TOK_RBRACK;}
"("			{ return TOK_LPAREN;}
")"			{ return TOK_RPAREN;}
"{"			{ return TOK_LBRACE;}
"}"			{ return TOK_RBRACE;}
"+"			{ return TOK_PLUS;}
"-"			{ return TOK_MINUS;}
"*"			{ return TOK_MULT;}
"/"			{ return TOK_DIV;}
"="			{ return TOK_ASSIGN;}
"&&"			{ return TOK_AND;}
"!"			{ return TOK_NOT;}
">"			{ return TOK_GT;}
"<"			{ return TOK_LT;}
"=="			{ return TOK_EQ;}

"!="			{ return TOK_NE;}
">="			{ return TOK_GE;}
"<="			{ return TOK_LE;}
"%"			{ return TOK_MOD;}
"^"			{ return TOK_BITXOR;}
"<<"			{ return TOK_SHL;}
">>"			{ return TOK_SHR;}
[\n|\r]			{ ++yylinenum;}

    /* Fill in the other operators */

 /**************** Recognize reserved words ****************/

 /* Basic types */

"enum"			{ return TOK_ENUM; }
"interface"		{ return TOK_INTERFACE;}
"bool"			{ return TOK_BOOL;}
"class"			{ return TOK_CLASS;}
"else"			{ return TOK_ELSE;}
"false"			{ return TOK_FALSE;}
"if"			{ return TOK_IF;}
"return"		{ return TOK_RETURN;}
"true"			{ return TOK_TRUE;}
"void"			{ return TOK_VOID;}
"int"			{ return TOK_INT;}
"string"			{ return TOK_STRING;}
"byte"			{ return TOK_BYTE;}
"double"			{ return TOK_DOUBLE;}
"print"			{ return TOK_PRINT;}
"event"			{ return TOK_EVENT;}
"any"			{ return TOK_ANY;}
"import"			{ return TOK_USE;}
"bit"			{ return TOK_BIT;}


{STRING}					{ return TOK_STRCONST;}


{UINTNUM}				        { 
							printf("%s", yytext);
							yylval.uVal = strtol(yytext,NULL,10);
							return TOK_UINTNUM;
						}

{HEX}						{
							printf("%s", yytext);
							yylval.uVal = strtol(yytext,NULL,16);
							return TOK_UINTNUM;
						}

{UINTNUM}"."({UINTNUM}*|{EXP})+ 		{
								char *end; printf("%s",yytext);
								yylval.dVal = strtod(yytext,&end); return TOK_DOUBLENUM;
						}

{ID}					{ yylval.cVal = yytext; return TOK_ID;}
 /**************** Unrecognized character ==> error ****************/

. {
	return TOK_SYNTAX_ERROR;
}

%%
