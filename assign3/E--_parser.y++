%{

#include "Ast.h"
#include "ParserUtil.h"
#include "Error.h"

using namespace std;

extern int verbosity;
extern int yylex();
extern void yyerror(const char *s);
int offSet;
extern const OpNode::OpInfo opInfo[];

void prt(string s)
{
//	cout<<s;
}
%}

%union{
  unsigned int 		 uVal;
  double             dVal;
  char*              cVal;
  vector<string>*    strVector;
  Value*             valVal;

  ExprNode*          exprVal;
  vector<ExprNode*>* exprList;
  RefExprNode*       refexpVal;

  ClassEntry*        classEntry;
  Type*              typeVal;
  vector<Type*>*     typeList; 

  EventEntry*        eventEntry;                        
  VariableEntry*     variableEntry;
  FunctionEntry*     functionEntry;

  BasePatNode*       patVal;
  PrimitivePatNode*  primPatVal;
  StmtNode*          stmtVal;
  list<StmtNode*>*   stmtList;
  IfNode*            ifVal;
  CompoundStmtNode*  compoundStmtVal;
  RuleNode*          ruleNode;

  vector<RuleNode*>* transList;
  
  vector<Type*>*     formalTypeVal;
  const OpNode::OpInfo*    funIval;
};

/* Operators */

%token TOK_LEX_ERROR TOK_PAT_STAR TOK_PAT_OR TOK_PAT_NOT
%token TOK_PLUS TOK_MINUS TOK_UMINUS TOK_MULT TOK_DIV TOK_MOD 
%token TOK_BITAND TOK_BITOR TOK_BITNOT TOK_BITXOR TOK_SHL TOK_SHR 
%token TOK_GT TOK_LT TOK_GE TOK_LE TOK_EQ  TOK_NE TOK_AND TOK_OR TOK_NOT 
%token TOK_COMMA TOK_ASSIGN TOK_SEMICOLON TOK_COLON TOK_ARROW
%token TOK_LBRACE TOK_RBRACE TOK_LPAREN TOK_RPAREN

/* Key words */

%token TOK_IF TOK_ELSE TOK_CLASS TOK_RETURN TOK_EVENT TOK_ANY TOK_PRINT 
%token TOK_UINTNUM TOK_DOUBLENUM TOK_VOID TOK_STRING TOK_STRCONST 
%token TOK_INT TOK_UNSIGNED TOK_BOOL TOK_BYTE TOK_DOUBLE TOK_SHORT
%token TOK_TRUE TOK_FALSE TOK_IDENT

/******************************** Type Info ********************************/

%type <cVal> TOK_IDENT TOK_PRINT variable_name
%type <strVector> variable_name_decl
%type <classEntry> class_decl
%type <typeVal> type_decl base_type 
%type <variableEntry> variable_decl param_decl
%type <uVal> TOK_UINTNUM 
%type <dVal> TOK_DOUBLENUM 
%type <eventEntry> event_decl_hdr param_list_star
%type <functionEntry> function_header

/* Uncomment types below as you start adding rules.
They are commented right now to prevent compile errors.
%type <patVal> event_pattern rule_body1
%type <primPatVal> event primitive_pat 
%type <exprList> expr_list expr_plus
%type <exprVal> expr function_invocation asg_stmt
%type <refexpVal> ref_expr
%type <ruleNode> rule
%type <strVector> id_list id_plus
%type <funIval> ev_or_fun
%type <valVal> literal
%type <stmtList> stmt_plus
%type <stmtVal> stmt simple_stmt
%type <compoundStmtVal> compoundStmt fun_rest
%type <ifVal>  if_then_else_stmt 

%type <typeList> formal_param_list 
%type <cVal> TOK_STRCONST
*/

/*********************   Precedence and Associativity    ********************/

%nonassoc TOK_ASSIGN

%left  TOK_PAT_OR 
%left  TOK_COLON
%left  TOK_PAT_STAR
%right TOK_PAT_NOT

%left  TOK_OR
%left  TOK_AND
%right TOK_NOT

%nonassoc TOK_EQ TOK_NE TOK_GT TOK_LT TOK_GE TOK_LE

%left  TOK_BITOR TOK_BITXOR
%left  TOK_BITAND
%right TOK_BITNOT 
%left  TOK_SHL TOK_SHR

%right TOK_DOUBLE_COLON

%left  TOK_PLUS TOK_MINUS
%left  TOK_MULT TOK_DIV TOK_MOD
%right TOK_UMINUS 

%left  TOK_LBRACK
%left  TOK_DOT

/**************************************************************************/

%start specification
%%

specification		: ifc_decl_star { prt("Spec"); }
;

ifc_decl_star		: /* empty */ {}
			| ifc_decl_star ifc_decl {}
			| ifc_decl_star error TOK_SEMICOLON {}
;

ifc_decl		: class_decl TOK_SEMICOLON  {}
			| variable_decl {}
			| event_decl {}
			| function_decl {}
			| TOK_SEMICOLON {}
;

//Class Declaration
class_decl		: TOK_CLASS TOK_IDENT {
						    $$ = new ClassEntry($2);
						    stm.insert($$);
					      }
;



//Base type

base_type		: TOK_INT		 { $$ = new Type(Type::TypeTag::INT);}
			| TOK_BOOL		 { $$ = new Type(Type::TypeTag::BOOL); }
			| TOK_BYTE		{ $$ = new Type(Type::TypeTag::BYTE); }
			| TOK_DOUBLE		{ $$ = new Type(Type::TypeTag::DOUBLE); }
			| TOK_VOID		{ $$ = new Type(Type::TypeTag::VOID); }
			| TOK_STRING		{ $$ = new Type(Type::TypeTag::STRING); }
			| TOK_UNSIGNED TOK_INT	    { $$ = new Type(Type::TypeTag::UINT); }
			| TOK_IDENT		    { 
							SymTabEntry *ste = stm.lookUp($1);
							if(ste == nullptr) {
							    $$ = new Type(Type::TypeTag::UNKNOWN);
							} else {
							    $$ = new Type(stm.lookUp($1), Type::TypeTag::CLASS);
							}
						    }
;

type_decl		: base_type {$$ = $1;} 		
;

/* Literals */
integer_literal_decl	: TOK_UINTNUM
;

double_literal_decl	: TOK_DOUBLENUM
;

bool_literal_decl	: TOK_TRUE
			| TOK_FALSE
;


literal_decl 		: integer_literal_decl {}
			| TOK_STRCONST {}
			| double_literal_decl {}
			| bool_literal_decl {}
;

literal_prt		: literal_decl { prt("Literal"); }
;

assignment_decl		: ref_exp TOK_ASSIGN exp	{ prt("Assignment"); }
;

exp			: literal_prt		
			| ref_exp
			| assignment_decl
			| function_invocation
			| exp TOK_PLUS exp				{ prt("Expr + Expr"); }
        		| exp TOK_MINUS exp    				{ prt("Expr - Expr");  }
        		| exp TOK_MULT exp    				{ prt("Expr * Expr"); }
        		| exp TOK_DIV exp     				{ prt("Expr / Expr"); }
			| exp TOK_AND exp				{ prt("Expr && Expr"); }
			| exp TOK_BITAND exp				{ prt("Expr & Expr"); }
			| exp TOK_BITOR exp				{ prt("Expr | Expr"); }
			| exp TOK_GT exp				{ prt("Expr > Expr"); }
			| exp TOK_GE exp				{ prt("Expr >= Expr"); }
			| exp TOK_LT exp				{ prt("Expr < Expr"); }
			| exp TOK_LE exp				{ prt("Expr <= Expr"); }
			| exp TOK_OR exp				{ prt("Expr || Expr"); }
			| exp TOK_SHL exp				{ prt("Expr << Expr"); }
			| exp TOK_SHR exp				{ prt("Expr >> Expr"); }
        		| exp TOK_BITXOR exp    			{ prt("Expr ^ Expr"); }
        		| exp TOK_MOD exp  	  			{ prt("Expr \% Expr"); }
        		| exp TOK_EQ exp    				{ prt("Expr == Expr"); }
        		| exp TOK_NE exp    				{ prt("Expr != Expr"); }
        		| TOK_BITNOT exp        			{ prt("~Expr"); }
        		| TOK_MINUS exp	        			{ prt("-Expr"); }
        		| TOK_NOT exp        				{ prt("!Expr"); }
        		| TOK_LPAREN exp TOK_RPAREN			{ prt("(Expr)"); }
         
;


rule				: event_pattern TOK_ARROW statement_decl       { prt("Rule"); }
;

rule_star			: rule_event
;

rule_event			: rule
				| rule_star rule
;
event_pattern			: primitive_pattern {}				
				| event_pattern TOK_PAT_STAR 			{ prt("EventPat **"); }
				| TOK_NOT event_pattern				{ prt("!EventPat"); }
				| event_pattern TOK_PAT_OR event_pattern 	{ prt("EventPat \\/ EventPat"); }
				| event_pattern TOK_COLON event_pattern 	{ prt("EventPat : EventPat"); }
				| TOK_LPAREN event_pattern TOK_RPAREN		{ prt("(EventPat)"); }
;

primitive_pattern		: pattern_type					{ prt("PrimitivePat"); }
				| pattern_type TOK_BITOR exp			{ prt("PrimitivePatWithCond"); }

;

pattern_type				: normal_event {}
					| any_event {}
;

any_event			: TOK_ANY{ prt("anyEvent"); }
;


event_decl_hdr			: TOK_EVENT TOK_IDENT					{   $$ = new EventEntry($2);
											    stm.insert($$);
											    stm.enterScope($$);
											    }
;

event_decl			: event_decl_hdr formal_param_list_decl TOK_SEMICOLON			{ stm.leaveScope(); }

normal_event 			: TOK_IDENT TOK_LPAREN variable_param_list_star TOK_RPAREN			{ prt("NormalEvent"); }

;

/*Statements*/
statement_decl			: TOK_SEMICOLON
				| only_if_without_else %prec "then"			{ prt("IfThenStmt"); }
				| only_if_without_else TOK_ELSE statement_decl		{ prt("IfThenElseStmt"); }
				| function_invocation TOK_SEMICOLON			{ prt("FunctionInvocationStmt"); }
				| assignment_decl TOK_SEMICOLON				{ prt("AssignStmt"); }
				| TOK_RETURN exp TOK_SEMICOLON 				{ prt("ReturnStmt");}
				| compound_statement_star
				| error TOK_SEMICOLON					{errMsg("Syntax error while parsing a statement");}
;

statement_decl_list		: statement_decl
				| statement_decl_list statement_decl
;

function_invocation		: TOK_IDENT function_invocation_list	{ prt("FunctionInvocation"); }
;

inside_function			: exp
				| inside_function TOK_COMMA exp
;

function_list			: /*empty*/
				| inside_function
;

function_invocation_list	: TOK_LPAREN function_list TOK_RPAREN
;

/* Function body */



function_body_decl		: variable_decl_list statement_decl_list
				| statement_decl_list
;

function_body_invoc		: TOK_LBRACE function_body_decl TOK_RBRACE	{ prt("FunctionBody"); }
;

/* If and Compund statements */

only_if_without_else		: TOK_IF exp statement_decl
;

compound_statement_decl		: TOK_LBRACE statement_decl_list TOK_RBRACE { prt("CompoundStmt"); }
;

compound_statement_star		: compound_statement_decl	%prec "reduce"
				| compound_statement_decl TOK_SEMICOLON
;

ref_exp				: TOK_IDENT					{ prt("RefExpr"); }
;

/* Variable parameter list */

variable_param_list_star	: /*empty*/
				| variable_param_list
;

variable_param_list		: TOK_IDENT  { }
				| variable_param_list TOK_COMMA TOK_IDENT {}
;

variable_name			: TOK_IDENT				{ $$ = $1; }
			//	| TOK_IDENT TOK_ASSIGN exp		{  }
;

// For variables 
variable_name_decl	: variable_name					{	$$ = new vector<string>();
										$$->push_back($1); }

			| variable_name_decl TOK_COMMA variable_name	{	$$->push_back($3); }

;

variable_decl		: type_decl variable_name_decl TOK_SEMICOLON	 	{ 
										 SymTabEntry *ste = stm.currentScope();
										 VariableEntry::VarKind vk = VariableEntry::VarKind::LOCAL_VAR;

										 if (ste->kind() == SymTabEntry::Kind::GLOBAL_KIND)
										    {
									    	
											vk = VariableEntry::VarKind::GLOBAL_VAR;
										    }
										    for(vector<string>::iterator it = $2->begin(); it != $2->end(); ++it) {
											stm.insert(new VariableEntry(*it, vk, $1));
										    }
										}
;

variable_decl_list	: variable_decl 
			| variable_decl_list variable_decl

;


param_list_star		: /* empty */	{ }
			| param_list	{ }
;

param_list			: param_decl			{
								} 

				| param_list TOK_COMMA param_decl	 { }
;

param_decl			: type_decl TOK_IDENT { 
							    stm.insert(new VariableEntry($2, VariableEntry::VarKind::PARAM_VAR, $1));
						      }
;

formal_param_list_decl		: TOK_LPAREN param_list_star TOK_RPAREN		   { }
				
;

function_header			: type_decl TOK_IDENT			{    $$ = new FunctionEntry($2); stm.insert($$); stm.enterScope($$); }

function_decl_only		: function_header formal_param_list_decl		    {}
;

function_decl			: function_decl_only TOK_SEMICOLON		{ stm.leaveScope(); }
				| function_decl_only function_body_invoc
;



%%
