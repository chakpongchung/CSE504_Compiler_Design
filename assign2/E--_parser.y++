%{
#include <iostream>
extern int yylex();
extern void yyerror(const char *s);
extern void errMsg(const char *s);
#define prt(x) cout << x << endl;
using namespace std;
%}

%union{
   char* cVal;
   unsigned int uVal;
   double dblVal;
};

/* Operators */

%token TOK_LEX_ERROR
%token TOK_GT TOK_LT TOK_GE TOK_LE TOK_EQ  TOK_NE 
%token TOK_COMMA TOK_ASSIGN TOK_SEMICOLON TOK_COLON TOK_ARROW
%token TOK_LBRACE TOK_RBRACE TOK_LPAREN TOK_RPAREN

/* Key words */

%token TOK_IF TOK_ELSE TOK_CLASS TOK_RETURN TOK_EVENT TOK_ANY TOK_PRINT 
%token TOK_ULONGNUM TOK_UINTNUM TOK_DOUBLENUM TOK_VOID TOK_STRING TOK_STRCONST 
%token TOK_INT TOK_UNSIGNED TOK_BOOL TOK_BYTE TOK_DOUBLE TOK_SHORT
%token TOK_LONG TOK_TRUE TOK_FALSE TOK_IDENT

/*********************   Precedence and Associativity    ********************/

%left 	TOK_PAT_OR
%left 	TOK_COLON
%left 	TOK_PAT_STAR
%right 	TOK_PAT_NOT
%left 	TOK_OR TOK_BITXOR
%left	TOK_AND
%right	TOK_NOT
%left	TOK_BITOR
%left 	TOK_BITAND
%right 	TOK_BITNOT
%left	TOK_SHL TOK_SHR		
%left	TOK_PLUS TOK_MINUS
%left 	TOK_MULT TOK_DIV TOK_MOD
%right 	TOK_UMINUS
%left	TOK_DOT

/**************************************************************************/

%start specification
%%

specification		: ifc_decl_star rule_star { prt("Spec"); }
;

ifc_decl_star		: /* empty */ {}
			| ifc_decl_star ifc_decl {}
			| ifc_decl_star error TOK_SEMICOLON { errMsg("Syntax error, expecting a declaration"); }
;

ifc_decl		: class_decl TOK_SEMICOLON { prt("ClassDecl"); }
			| function_decl {}
 			| event_decl {}
			| variable_decl {}
			| TOK_SEMICOLON {}
;


integer_literal_decl	: TOK_UINTNUM
;

double_literal_decl	: TOK_DOUBLENUM
;

bool_literal_decl	: TOK_TRUE
			| TOK_FALSE
;

long_literal_decl	: TOK_ULONGNUM
;

literal_decl 		: integer_literal_decl {}
			| TOK_STRCONST {}
			| double_literal_decl {}
			| bool_literal_decl {}
			| long_literal_decl {}
;

literal_prt		: literal_decl { prt("Literal"); }
;

exp			: literal_prt		
			| exp TOK_PLUS exp				{ prt("Exp + Exp"); }
        		| exp TOK_MINUS exp    				{ prt("Exp - Exp");  }
        		| exp TOK_MULT exp    				{ prt("Exp * Exp"); }
        		| exp TOK_DIV exp     				{ prt("Exp / Exp"); }
			| exp TOK_AND exp				{ prt("Exp && Exp"); }
			| exp TOK_BITAND exp				{ prt("Exp & Exp"); }
			| exp TOK_BITOR exp				{ prt("Exp | Exp"); }
			| exp TOK_GT exp				{ prt("Exp > Exp"); }
			| exp TOK_GE exp				{ prt("Exp >= Exp"); }
			| exp TOK_LT exp				{ prt("Exp < Exp"); }
			| exp TOK_LE exp				{ prt("Exp <= Exp"); }
			| exp TOK_OR exp				{ prt("Exp || Exp"); }
			| exp TOK_SHL exp				{ prt("Exp << Exp"); }
			| exp TOK_SHR exp				{ prt("Exp >> Exp"); }
        		| exp TOK_BITXOR exp    			{ prt("Exp ^ Exp"); }
        		| exp TOK_EQ exp    				{ prt("Exp == Exp"); }
        		| exp TOK_NE exp    				{ prt("Exp != Exp"); }
        		| TOK_BITNOT exp        			{ prt("~Exp"); }
        		| TOK_UMINUS exp        			{ prt("-Exp"); }
        		| TOK_NOT exp        				{ prt("!Exp"); }
        		| TOK_LPAREN exp TOK_RPAREN			{ prt("(Exp)"); }
         

;


rule_star		: /* fill in */
;


event_decl		: TOK_EVENT
;

variable_name		: TOK_IDENT								{ prt("VariableDecl"); }
			| TOK_IDENT TOK_ASSIGN exp						{ prt("VariableDecWithInit"); }
;

variable_name_decl	: variable_name
			| variable_name_decl TOK_COMMA variable_name
;

variable_decl		: type_prt variable_name_decl TOK_SEMICOLON	 			
;

class_decl		: TOK_CLASS TOK_IDENT {}
;

type_prt		: type_decl { prt("Type"); }
;

type_decl		: TOK_INT {}
			| TOK_BOOL {}
			| TOK_BYTE {}
			| TOK_DOUBLE {}
			| TOK_SHORT {}
			| TOK_VOID {}
			| TOK_LONG {}
			| TOK_STRING {}
;

param_list		: /* empty */ {}
			| param_decl {}
			| param_list TOK_COMMA param_decl {}
;

param_decl		: type_prt TOK_IDENT{ prt("FormalParam"); }
;

formal_param_list_decl	: TOK_LPAREN param_list TOK_RPAREN { prt("FormalParamList"); }
;

function_decl		: type_prt TOK_IDENT formal_param_list_decl { prt("FunctionDecl"); }
;


%%
void yyerror(string s)
{
  extern int yylineno;	// defined and maintained in lex.c
  extern char *yytext;	// defined and maintained in lex.c
  
  cerr << "ERROR: " << s << " at symbol \"" << yytext;
  cerr << "\" on line " << yylineno << endl;
  exit(1);
}

void yyerror(char *s)
{
  yyerror(string(s));
}


